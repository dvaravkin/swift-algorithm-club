# Сортировка пузырьком

Сортировка пузырьком — это алгоритм сортировки, который начинается с начала массива и меняет местами первые два элемента только в том случае, если первый элемент больше второго. Затем это сравнение переносится на следующую пару и так далее. Это продолжается до тех пор, пока массив не будет полностью отсортирован. Меньшие элементы постепенно «всплывают» в начало массива. Иногда этот алгоритм называют сортировкой с погружением, так как более крупные или тяжёлые элементы опускаются в конец массива.

##### Время выполнения:
- В среднем: O(N^2)
- Худший вариант: O(N^2)

##### Память:
- O(1)

### Реализация:

Реализация не будет приведена, так как среднее и худшее время выполнения показывают, что это очень неэффективный алгоритм. Однако понимание этой концепции поможет вам понять основы простых алгоритмов сортировки.

Пузырьковая сортировка — это очень простой алгоритм сортировки. Он заключается в сравнении пар соседних элементов в массиве. Если первый элемент больше, они меняются местами, в противном случае ничего не делается и продолжается следующее сравнение. 
Это достигается за счёт просмотра массива `n` раз, где `n` — количество элементов в массиве.

![animated gif of the bubble sort algorithm](https://s3.amazonaws.com/codecademy-content/programs/tdd-js/articles/BubbleSort.gif)

На этом GIF-изображении показана обратная реализация

#### Пример
Давайте возьмём массив `[5, 1, 4, 2, 8]` и отсортируем его от наименьшего числа к наибольшему с помощью пузырьковой сортировки. На каждом этапе сравниваются элементы, выделенные жирным шрифтом. Потребуется три прохода.

##### Первый Проход
[ **5 1** 4 2 8 ] -> [ **1 5** 4 2 8 ], Здесь алгоритм сравнивает первые два элемента и меняет их местами, поскольку 5 > 1.

[ 1 **5 4** 2 8 ] -> [ 1 **4 5** 2 8 ], меняет местами, так как 5 > 4

[ 1 4 **5 2** 8 ] -> [ 1 4 **2 5** 8 ], меняет местами, так как 5 > 2 

[ 1 4 2 **5 8** ] -> [ 1 4 2 **5 8** ], здесь, поскольку эти элементы уже расположены по порядку (8 > 5), алгоритм не меняет их местами.

##### Второй проход
[ **1 4** 2 5 8 ] -> [ **1 4** 2 5 8 ]

[ 1 **4 2** 5 8 ] -> [ 1 **2 4** 5 8 ], меняет местами, так как 4 > 2 

[ 1 2 **4 5** 8 ] -> [ 1 2 **4 5** 8 ]

[ 1 2 4 **5 8** ] -> [ 1 2 4 **5 8** ]
Теперь массив уже отсортирован, но алгоритм не знает, завершена ли сортировка. Алгоритму нужен один полный проход без перестановок, чтобы понять, что массив отсортирован.

##### Третий Проход
[ **1 2** 4 5 8 ] -> [ **1 2** 4 5 8 ]

[ 1 **2 4** 5 8 ] -> [ 1 **2 4** 5 8 ]

[ 1 2 **4 5** 8 ] -> [ 1 2 **4 5** 8 ]

[ 1 2 4 **5 8** ] -> [ 1 2 4 **5 8** ]

То же самое происходит на четвёртом и пятом проходах.

#### Код
```swift
for i in 0..<array.count {
  for j in 1..<array.count {
    if array[j] < array[j-1] {
      let tmp = array[j-1]
      array[j-1] = array[j]
      array[j] = tmp
    }
  }
}
return array
```

#### Оптимизация
Алгоритм пузырьковой сортировки можно легко оптимизировать, если заметить, что при `n-ном` проходе находится `n-й` самый большой элемент, который помещается в конец массива. Таким образом, внутренний цикл может не просматривать последние `n-1` элементы при выполнении за `n` раз:


```swift
for i in 0..<array.count {
  for j in 1..<array.count - i {
    if array[j] < array[j-1] {
      let tmp = array[j-1]
      array[j-1] = array[j]
      array[j] = tmp
    }
  }
}
return array
```

Единственное изменение коснулось второй строки: интервал `1..<array.count` был заменён на `1..<array.count - i`, что фактически сократило количество сравнений вдвое.

Для массива `[5, 1, 4, 2, 8]` упорядочивание с оптимизированным кодом будет выглядеть примерно так:

##### Первый Проход
[ **5 1** 4 2 8 ] -> [ **1 5** 4 2 8 ], меняет местами, так как 5 > 1

[ 1 **5 4** 2 8 ] -> [ 1 **4 5** 2 8 ], меняет местами, так как 5 > 4 

[ 1 4 **5 2** 8 ] -> [ 1 4 **2 5** 8 ], меняет местами, так как 5 > 2 

[ 1 4 2 **5 8** ] -> [ 1 4 2 **5 8** ], здесь, поскольку эти элементы уже упорядочены (8 > 5), алгоритм не меняет их местами.

*к концу первого прохода последний элемент гарантированно будет самым большим*

##### Второй Проход
[ **1 4** 2 5 8 ] -> [ **1 4** 2 5 8 ]

[ 1 **4 2** 5 8 ] -> [ 1 **2 4** 5 8 ], меняет местами, так как 4 > 2 

[ 1 2 **4 5** 8 ] -> [ 1 2 **4 5** 8 ], поскольку первый цикл выполнился один раз, внутренний цикл останавливается здесь, не сравнивая 5 с 8

##### Третий Проход

[ **1 2** 4 5 8 ] -> [ **1 2** 4 5 8 ]

[ 1 **2 4** 5 8 ] -> [ 1 **2 4** 5 8 ] аналогично, на одно сравнение меньше

##### Четвертый Проход
[ **1 2** 4 5 8 ] -> [ **1 2** 4 5 8 ]

Пятого прохода нет

#### Заключение

Даже с учётом предложенных оптимизаций этот алгоритм сортировки по-прежнему крайне неэффективен. Хорошей альтернативой является [сортировка слиянием](https://github.com/dvaravkin/swift-algorithm-club/tree/master/Merge%20Sort), которая не только работает лучше, но и имеет схожую сложность реализации.

*Обновлено для Swift Algorithm Club Хулио Бразилиа*

##### Вспомогательные ссылки
[Code Pumpkin](https://codepumpkin.com/bubble-sort/)
[Wikipedia](https://en.wikipedia.org/wiki/Bubble_sort)
[GeeksforGeeks](https://www.geeksforgeeks.org/bubble-sort/)
