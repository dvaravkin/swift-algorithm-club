**([English version](https://github.com/dvaravkin/swift-algorithm-club/tree/master/Binary%20Search/README.md))**

# Бинарный поиск

Цель: быстро найти элемент в массиве.

Допустим, у вас есть массив чисел, и вы хотите определить, находится ли конкретное число в этом массиве, и если да, то по какому индексу.

В большинстве случаев для этого достаточно функции Swift `Collection.index(of:)`:

```swift
let numbers = [11, 59, 3, 2, 53, 17, 31, 7, 19, 67, 47, 13, 37, 61, 29, 43, 5, 41, 23]

numbers.index(of: 43)  // возвращает 15
```

Встроенная функция `Collection.index(of:)` выполняет [линейный поиск](../Linear%20Search/). В коде это выглядит примерно так:

```swift
func linearSearch<T: Equatable>(_ a: [T], _ key: T) -> Int? {
    for i in 0 ..< a.count {
        if a[i] == key {
            return i
        }
    }
    return nil
}
```

И вы будете использовать его вот так:

```swift
linearSearch(numbers, 43)  // возвращает 15
```

Так в чем же проблема? Функция `linearSearch()` перебирает весь массив с самого начала, пока не найдет искомый элемент. В худшем случае значение даже не находится в массиве, и вся эта работа оказывается напрасной.

В среднем алгоритму линейного поиска требуется просмотреть половину значений в массиве. Если ваш массив достаточно велик, это будет очень медленно!

## Разделяй и властвуй

Классический способ ускорить эту работу - использовать *бинарный поиск*. Хитрость заключается в том, чтобы продолжать делить массив пополам, пока значение не будет найдено.

Для массива размера `n` производительность составляет не **O(n)**, как при линейном поиске, а всего лишь **O(log n)**. Для сравнения, бинарный поиск в массиве с 1 000 000 элементами требует всего 20 шагов для нахождения искомого значения, поскольку `log_2(1 000 000) = 19,9`. А для массива с миллиардом элементов требуется всего 30 шагов. (Опять же, когда вы в последний раз использовали массив с миллиардом элементов?)

Звучит здорово, но есть и обратная сторона использования двоичного поиска: массив должен быть отсортирован. На практике это обычно не является проблемой.

Вот как работает двоичный поиск:

- Разделите массив пополам и определите, где находится искомый объект, называемый *ключом поиска*, - в левой половине или в правой.
- Как определить, в какой половине находится ключ поиска? Именно поэтому сначала выполняется сортировка массива, чтобы можно было выполнить простое сравнение `<` или `>`.
- Если ключ поиска находится в левой половине, вы повторяете процесс: разбиваете левую половину на две еще более мелкие части и смотрите, в какой части должен находиться ключ поиска. (Аналогично, если это правая половина).
- Так повторяется до тех пор, пока не будет найден искомый ключ. Если массив не удается разделить еще больше, следует с сожалением заключить, что искомого ключа в массиве нет.

Теперь вы знаете, почему этот поиск называется "бинарным": на каждом шаге массив делится на две половины. Именно этот процесс *разделяй и властвуй* позволяет быстро определить, где должен находиться ключ поиска.

## Код

Ниже представлена рекурсивная реализация двоичного поиска на Swift:

```swift
func binarySearch<T: Comparable>(_ a: [T], key: T, range: Range<Int>) -> Int? {
    if range.lowerBound >= range.upperBound {
        // Если мы попали сюда, значит, искомый ключ отсутствует в массиве.
        return nil

    } else {
        // Определяем, где нужно разделить массив.
        let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2

        // Ключ поиска находится в левой половине?
        if a[midIndex] > key {
            return binarySearch(a, key: key, range: range.lowerBound ..< midIndex)

        // Ключ поиска находится в правой половине?
        } else if a[midIndex] < key {
            return binarySearch(a, key: key, range: midIndex + 1 ..< range.upperBound)

        // Если мы попадем сюда, значит, мы нашли ключ поиска!
        } else {
            return midIndex
        }
    }
}
```

Чтобы проверить это, скопируйте код на playground и выполните:

```swift
let numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]

binarySearch(numbers, key: 43, range: 0 ..< numbers.count)  // gives 13
```

Обратите внимание, что массив `numbers` отсортирован. Иначе алгоритм двоичного поиска не будет работать!

На самом деле мы не создаем два новых массива. Вместо этого мы отслеживаем эти разбиения с помощью объекта Swift `Range`. Изначально этот диапазон охватывает весь массив, `0 ...< numbers.count`.  По мере того как мы разбиваем массив, диапазон становится все меньше и меньше.

> **Примечание:** Следует помнить, что `range.upperBound` всегда указывает на элемент за последним. В примере диапазон равен `0..<19`, потому что в массиве 19 чисел, и поэтому `range.lowerBound = 0` и `range.upperBound = 19`. Но в нашем массиве последний элемент находится под индексом 18, а не 19, поскольку мы начинаем отсчет от 0. Помните об этом при работе с диапазонами: `верхняя граница` всегда на один больше, чем индекс последнего элемента.

## Разбираем пример

Возможно, будет полезно рассмотреть работу алгоритма в деталях.

Массив из примера выше состоит из 19 чисел и в отсортированном виде выглядит следующим образом:

	[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67 ]

Мы пытаемся определить, есть ли в этом массиве число `43`.

Чтобы разделить массив пополам, нам нужно знать индекс элемента в середине. Он определяется этой строкой:

```swift
let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2
```

Изначально диапазон имеет значения `lowerBound = 0` и `upperBound = 19`. Заполнив эти значения, мы обнаруживаем, что `midIndex` равен `0 + (19 - 0)/2 = 19/2 = 9`. На самом деле это `9,5`, но поскольку мы используем целые числа, ответ округляется в меньшую сторону.

На следующем рисунке `*` показывает средний элемент. Как видите, количество элементов с каждой стороны одинаково, так что мы делим прямо посередине.

	[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67 ]
                                      *

Теперь бинарный поиск определит, какую половину использовать. Соответствующая часть кода выглядит так:

```swift
if a[midIndex] > key {
    // используем левую половину
} else if a[midIndex] < key {
    // используем правую половину
} else {
    return midIndex
}
```

В данном случае `a[midIndex] = 29`. Это меньше, чем ключ поиска, поэтому мы можем с уверенностью заключить, что ключ поиска никогда не будет находиться в левой половине массива. Ведь левая половина содержит только числа, меньшие, чем `29`. Следовательно, ключ поиска должен находиться где-то в правой половине (или вообще отсутствовать в массиве).

Теперь мы можем просто повторить бинарный поиск, но на интервале массива от `midIndex + 1` до `range.upperBound`:

	[ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43, 47, 53, 59, 61, 67 ]

Поскольку нам больше не нужно заниматься левой половиной массива, я пометил ее символами `x`. Теперь мы будем рассматривать только правую половину, которая начинается с индекса массива 10.

Вычислим индекс нового среднего элемента: `midIndex = 10 + (19 - 10)/2 = 14`, и снова разделим массив посередине.

	[ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43, 47, 53, 59, 61, 67 ]
	                                                 *

Как видите, `a[14]` действительно является средним элементом правой половины массива.

Ключ поиска больше или меньше, чем `a[14]`? Меньше, потому что `43 < 47`. На этот раз мы берем левую половину и игнорируем большие числа справа:

	[ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43 | x, x, x, x, x ]

Новый `midIndex` находится здесь:

	[ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43 | x, x, x, x, x ]
	                                     *

Ключ поиска больше, чем `37`, поэтому продолжим с правой половины:

	[ x, x, x, x, x, x, x, x, x, x | x, x | 41, 43 | x, x, x, x, x ]
	                                        *

И снова ключ поиска больше, поэтому разделим еще раз и возьмем правую половину:

	[ x, x, x, x, x, x, x, x, x, x | x, x | x | 43 | x, x, x, x, x ]
	                                            *

И вот теперь все готово. Ключ поиска равен искомому элементу массива, так что мы наконец нашли то, что искали: число `43` находится в массиве с индексом `13`.

Это могло показаться большой работой, но на самом деле потребовалось всего четыре шага, чтобы найти ключ поиска в массиве, что звучит правдоподобно, потому что `log_2(19) = 4,23`. При линейном поиске это заняло бы 14 шагов.

Что произойдет, если мы будем искать `42` вместо `43`? В этом случае мы не сможем разделить массив дальше. Значение `range.upperBound` становится меньше значения `range.lowerBound`. Это означает, что искомый ключ находится не в массиве, и алгоритм возвращает `nil`.

> **Примечание:** Многие реализации двоичного поиска вычисляют `midIndex = (lowerBound + upperBound) / 2`. Это не верно. Есть одна тонкость, которая проявляется только на очень больших массивах, потому что `lowerBound + upperBound` может выйти за предел максимального числа, которое может содержать целое число. Такая ситуация вряд ли произойдет на 64-битном процессоре, но точно может произойти на 32-битных машинах.

## Итеративный поиск против рекурсивного

Бинарный поиск является рекурсивным по своей природе, поскольку вы применяете одну и ту же логику снова и снова к все меньшим и меньшим подмассивам. Однако это не означает, что вы должны реализовывать `binarySearch()` как рекурсивную функцию. Часто эффективнее преобразовать рекурсивный алгоритм в итеративную версию, используя простой цикл вместо множества вызовов рекурсивных функций.

Вот итеративная реализация бинарного поиска в Swift:

```swift
func binarySearch<T: Comparable>(_ a: [T], key: T) -> Int? {
    var lowerBound = 0
    var upperBound = a.count
    while lowerBound < upperBound {
        let midIndex = lowerBound + (upperBound - lowerBound) / 2
        if a[midIndex] == key {
            return midIndex
        } else if a[midIndex] < key {
            lowerBound = midIndex + 1
        } else {
            upperBound = midIndex
        }
    }
    return nil
}
```

Как видите, код очень похож на рекурсивную версию. Основное отличие заключается в использовании цикла `while`.

Используется он следующим образом:

```swift
let numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]

binarySearch(numbers, key: 43)  // выдает 13
```

## Заключение

Является ли проблемой то, что массив должен быть сначала отсортирован? Это зависит от ситуации. Помните, что сортировка требует времени - комбинация двоичного поиска и сортировки может быть медленнее, чем простой линейный поиск. Двоичный поиск выигрывает в ситуациях, когда вы сортируете только один раз, а затем выполняете множество поисков.

См. также [Википедия](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA).

*Написано для Swift Algorithm Club Маттисом Холлемансом (Matthijs Hollemans)*.
